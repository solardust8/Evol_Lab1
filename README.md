# **Введение**
Цель работы:

Получить навыки вычисления сложности алгоритмов и их оптимизации различными методами.

Задачи работы:

1. Реализовать на любом ЯП алгоритм, согласно варианту задания.
1. Вычислить сложность алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов.
1. Выполнить оптимизацию как алгоритмическую если возможно, с выносом инварианта, например, так и программными методами выбранного ЯП.
1. Вычислить сложность оптимизированного алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов.
1. Описать различие величин сложности, результатов, привести обоснование.
1. Сформулировать выводы.
1. Приложить код в виде ссылки на публичный репозиторий.

# **Ход выполнения**
В ходе настоящей лабораторной работы был реализован [алгоритм Ли](https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B8) (алгоритм волновой трассировки).

Алгоритм Ли, также известный как алгоритм волновой трассировки, используется для поиска кратчайшего пути от начальной точки к конечной в планарном графе. Он относится к классу алгоритмов поиска пути.

Основная идея алгоритма Ли заключается в том, что он распространяет "волну" от начальной точки по графу до тех пор, пока не достигнет конечной точки. При этом каждая ячейка графа (узел планарного графа) получает значение, равное инкременту «волновых фронтов» из начальной точки. Принадлежит к алгоритмам, основанным на методах поиска в ширину. Таким образом, после завершения работы алгоритма, можно восстановить кратчайший путь от конечной точки до начальной.

**Уточнения задачи:** граф будет задаваться на плоскости квадратной матрицей с произвольной стороной, при этом проходимость и непроходимость «клеток» будет задаваться в стиле «пещеры» (когда клетка может быть пустой или может содержать препятствие), волна распространяется в окрестности Мура (окрестность фон Неймана + диагональные клетки). Пояснение: в случае матрицы 2х2 и непроходимости основной диагонали – побочная считается проходимой. 

Реализацию алгоритма студентом можно видеть в **репозитории**. Алгоритм реализован на языке С++ без привязки к конкретному стандарту (не менее 11), а так же с использованием winapi для получения информации о задействованных ресурсах. 

Преимущественно алгоритм реализован с применением структур данных из STL (vector, queue, pair) – базовые операции поиска, вставки и т.д. в которых выполняются за O(1)/O(n). 

Я затруднился писать заведомо неэффективное решение, а посему на базовом уровне (без доп. твиков, трюков и мелочей) исполнил оптимальное решение (с алгоритмической точки зрения, аналогичное поиску в ширину с очередью). Так же студент руководствуется советами из [**статьи](https://www.eventhelix.com/embedded/optimizing-c-and-cpp-code/)** для оптимизации кода при написании.

«Пещера» представляет из себя сильно разреженный граф с числом ребер O(n) (где n – число клеток). Число вершин (клеток), по которым мы пройдем, так же O(n). А значит <b>вычислительная сложность получившейся реализации не превысит О(n<sup>2</sup>).</b>

Теперь можно перейти к тестам. Карты генерируются случайно для заданного значения размерности матрицы. Без дополнительной оптимизации алгоритм в среднем показывает следующие показатели:


|**N**|**32\*32**|**64\*64**|**128\*128**|**512\*512**|**1024\*1024**|
| :-: | :-: | :-: | :-: | :-: | :-: |
|**VMem, Kb**|944|952|1060|3128|9628|
|**PhyMem, Kb**|3392|3420|3524|5564|11920|
|**Runtime, ms**|0-1|0-1|1|20-24|115-125|

Само собой, реализацию можно ускорить, отказавшись от структур данных из STL (в стеке только указатели на кучу, задержки на конструкторах и аллокаторе и т.д. и т.п.) в пользу исполнения  в C стиле, утилизируя для всего массивы (в стеке целиком) и самописные низкоуровневые методы (по типу XOR свапа). Но это крайне сильно затрудняет чтение кода, распространено на школьных олимпиадах и при программировании на встроенных устройствах (и очень мало где еще).

Вместо этого, давайте попробуем на этапе компиляции (GNU G++) задействовать флаги для оптимизации -О1, -О2, и самый жесткий -О3. В общем и целом, различие опций в том, что -O2 предоставляет некоторый набор оптимизаций, не изменяющих соотношение скорость-размер, а -O3 добавляет оптимизации, которые чаще всего полагаются на подход "занять больше места, но работать быстрее". Иными словами, в грубом режиме оптимизации компилятор попытается заанролить все возможные циклы/вызовы, компактно и в одном месте переконструировать методы (вынести низкоуровневые инварианты, расположить рядом, спрогнозировать попадания в кеш и т.п.), пересчитать как можно больше доступных числовых данных и запихнуть это в стек, после чего выровнять. Более подробно и корректно объясняется в [man gcc](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html).

Результаты для **1024\*1024**:

|**Опция**|**-О1**|**-О2**|**-О3**|
| :-: | :-: | :-: | :-: |
|**VMem, Kb**|9632|9632|9628|
|**PhyMem, Kb**|11856|11856|11860|
|**Runtime, ms**|40|37|37|

# **Вывод**
В ходе настоящей работы студентом был реализован алгоритм Ли волновой трассировки на языке С++ с применением структур данных из STL. Реализация является оптимальной  с алгоритмической точки зрения, <b>вычислительная сложность получившейся реализации не превысит О(n<sup>2</sup>).</b> Студент применил оптимизационные флаги компилятора -О1-3 GNU G++, и уже на самом мягком режиме -О1 быстродействие улучшилось в 3 раза, однако более экстремальные флаги оптимизации не дали более ощутимого прироста (вероятно из-за динамичности структур данных из STL и малого размера самой программы).


